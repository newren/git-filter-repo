'\" t
.\"     Title: git-filter-repo
.\"    Author: [FIXME: author] [see http://www.docbook.org/tdg5/en/html/author]
.\" Generator: DocBook XSL Stylesheets vsnapshot <http://docbook.sf.net/>
.\"      Date: 2024-11-23
.\"    Manual: Git Manual
.\"    Source: Git 2.47.0.319.g447b6794a4a.dirty
.\"  Language: English
.\"
.TH "GIT\-FILTER\-REPO" "1" "2024\-11\-23" "Git 2\&.47\&.0\&.319\&.g447b67" "Git Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
git-filter-repo \- Rewrite repository history
.SH "SYNOPSIS"
.sp
.nf
\fIgit filter\-repo\fR \-\-analyze
\fIgit filter\-repo\fR [<path_filtering_options>] [<content_filtering_options>]
        [<ref_renaming_options>] [<commit_message_filtering_options>]
        [<name_or_email_filtering_options>] [<parent_rewriting_options>]
        [<generic_callback_options>] [<miscellaneous_options>]
.fi
.sp
.SH "DESCRIPTION"
.sp
Rapidly rewrite entire repository history using user\-specified filters\&. This is a destructive operation which should not be used lightly; it writes new commits, trees, tags, and blobs corresponding to (but filtered from) the original objects in the repository, then deletes the original history and leaves only the new\&. See the section called \(lqDISCUSSION\(rq for more details on the ramifications of using this tool\&. Several different types of history rewrites are possible; examples include (but are not limited to):
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
stripping large files (or large directories or large extensions)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
stripping unwanted files by path
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
extracting wanted paths and their history (stripping everything else)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
restructuring the file layout (such as moving all files into a subdirectory in preparation for merging with another repo, making a subdirectory become the new toplevel directory, or merging two directories with independent filenames into one directory)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
renaming tags (also often in preparation for merging with another repo)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
replacing or removing sensitive text such as passwords
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
making mailmap rewriting of user names or emails permanent
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
making grafts or replacement refs permanent
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
rewriting commit messages
.RE
.sp
Additionally, several concerns are handled automatically (many of these can be overridden, but they are all on by default):
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
rewriting (possibly abbreviated) hashes in commit messages to refer to the new post\-rewrite commit hashes
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
pruning commits which become empty due to the above filters (also handles edge cases like pruning of merge commits which become degenerate and empty)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
rewriting stashes
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
baking the changes made by refs/replace/ refs into the permanent history and removing the replace refs
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
stripping of original history to avoid mixing old and new history
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
repacking the repository post\-rewrite to shrink the repo for the user
.RE
.sp
And additional facilities are available via a config option
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
creating replace\-refs (see
\fBgit-replace\fR(1)) for old commit hashes, which if manually pushed and fetched will allow users to continue to refer to new commits using (unabbreviated) old commit IDs
.RE
.sp
Also, it\(cqs worth noting that there is an important safety mechanism:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
abort if run from a repo that is not a fresh clone (to prevent accidental data loss from rewriting local history that doesn\(cqt exist anywhere else)\&. See
the section called \(lqFRESH CLONE SAFETY CHECK AND \-\-FORCE\(rq\&.
.RE
.sp
For those who know that there is large unwanted stuff in their history and want help finding it, this command also
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
provides an option to analyze a repository and generate reports that can be useful in determining what to filter (or in determining whether a separate filtering command was successful)\&.
.RE
.sp
See also the section called \(lqVERSATILITY\(rq, the section called \(lqDISCUSSION\(rq, the section called \(lqEXAMPLES\(rq, and the section called \(lqINTERNALS\(rq\&.
.SH "OPTIONS"
.SS "Analysis Options"
.PP
\-\-analyze
.RS 4
Analyze repository history and create a report that may be useful in determining what to filter in a subsequent run (or in determining if a previous filtering command did what you wanted)\&. Will not modify your repo\&.
.RE
.SS "Filtering based on paths (see also \-\-filename\-callback)"
.sp
These options specify the paths to select\&. Note that much like git itself, renames are NOT followed so you may need to specify multiple paths, e\&.g\&. \fB\-\-path\fR \fBolddir/\fR \fB\-\-path\fR \fBnewdir/\fR
.PP
\-\-invert\-paths
.RS 4
Invert the selection of files from the specified \-\-path\-{match,glob,regex} options below, i\&.e\&. only select files matching none of those options\&.
.RE
.PP
\-\-path\-match <dir_or_file>, \-\-path <dir_or_file>
.RS 4
Exact paths (files or directories) to include in filtered history\&. Multiple \-\-path options can be specified to get a union of paths\&.
.RE
.PP
\-\-path\-glob <glob>
.RS 4
Glob of paths to include in filtered history\&. Multiple \-\-path\-glob options can be specified to get a union of paths\&.
.RE
.PP
\-\-path\-regex <regex>
.RS 4
Regex of paths to include in filtered history\&. Multiple \-\-path\-regex options can be specified to get a union of paths\&.
.RE
.PP
\-\-use\-base\-name
.RS 4
Match on file base name instead of full path from the top of the repo\&. Incompatible with \-\-path\-rename, and incompatible with matching against directory names\&.
.RE
.SS "Renaming based on paths (see also \-\-filename\-callback)"
.sp
Note: if you combine path filtering with path renaming, be aware that a rename directive does not select paths, it only says how to rename paths that are selected with the filters\&.
.PP
\-\-path\-rename <old_name:new_name>, \-\-path\-rename\-match <old_name:new_name>
.RS 4
Path to rename; if filename or directory matches <old_name> rename to <new_name>\&. Multiple \-\-path\-rename options can be specified\&.
.RE
.SS "Path shortcuts"
.PP
\-\-paths\-from\-file <filename>
.RS 4
Specify several path filtering and renaming directives, one per line\&. Lines with
\fB==\fR> in them specify path renames, and lines can begin with
\fBliteral:\fR
(the default),
\fBglob:\fR, or
\fBregex:\fR
to specify different matching styles\&. Blank lines and lines starting with a # are ignored (if you have a filename that you want to filter on that starts with
\fBliteral:\fR, #,
\fBglob:\fR, or
\fBregex:\fR, then prefix the line with
\fIliteral:\fR)\&.
.RE
.PP
\-\-subdirectory\-filter <directory>
.RS 4
Only look at history that touches the given subdirectory and treat that directory as the project root\&. Equivalent to using
\fB\-\-path\fR
\fI<directory>\fR\fB/\fR
\fB\-\-path\-rename\fR
\fI<directory>\fR\fB/:\fR
.RE
.PP
\-\-to\-subdirectory\-filter <directory>
.RS 4
Treat the project root as if it were under <directory>\&. Equivalent to using
\fB\-\-path\-rename\fR
\fB:\fR\fI<directory>\fR\fB/\fR
.RE
.SS "Content editing filters (see also \-\-blob\-callback)"
.PP
\-\-replace\-text <expressions_file>
.RS 4
A file with expressions that, if found, will be replaced\&. By default, each expression is treated as literal text, but
\fBregex:\fR
and
\fBglob:\fR
prefixes are supported\&. You can end the line with
\fB==\fR> and some replacement text to choose a replacement choice other than the default of ***REMOVED***\&.
.RE
.PP
\-\-strip\-blobs\-bigger\-than <size>
.RS 4
Strip blobs (files) bigger than specified size (e\&.g\&.
\fB5M\fR,
\fB2G\fR, etc)
.RE
.PP
\-\-strip\-blobs\-with\-ids <blob_id_filename>
.RS 4
Read git object ids from each line of the given file, and strip all of them from history
.RE
.SS "Renaming of refs (see also \-\-refname\-callback)"
.PP
\-\-tag\-rename <old:new>
.RS 4
Rename tags starting with <old> to start with <new>\&. For example, \-\-tag\-rename foo:bar will rename tag foo\-1\&.2\&.3 to bar\-1\&.2\&.3; either <old> or <new> can be empty\&.
.RE
.SS "Filtering of commit messages (see also \-\-message\-callback)"
.PP
\-\-replace\-message <expressions_file>
.RS 4
A file with expressions that, if found in commit or tag messages, will be replaced\&. This file uses the same syntax as \-\-replace\-text\&.
.RE
.PP
\-\-preserve\-commit\-hashes
.RS 4
By default, since commits are rewritten and thus gain new hashes, references to old commit hashes in commit messages are replaced with new commit hashes (abbreviated to the same length as the old reference)\&. Use this flag to turn off updating commit hashes in commit messages\&.
.RE
.PP
\-\-preserve\-commit\-encoding
.RS 4
Do not reencode commit messages into UTF\-8\&. By default, if the commit object specifies an encoding for the commit message, the message is re\-encoded into UTF\-8\&.
.RE
.SS "Filtering of names & emails (see also \-\-name\-callback and \-\-email\-callback)"
.PP
\-\-mailmap <filename>
.RS 4
Use specified mailmap file (see
\fBgit-shortlog\fR(1)
for details on the format) when rewriting author, committer, and tagger names and emails\&. If the specified file is part of git history, historical versions of the file will be ignored; only the current contents are consulted\&.
.RE
.PP
\-\-use\-mailmap
.RS 4
Same as:
\fI\-\-mailmap \&.mailmap\fR
.RE
.SS "Parent rewriting"
.PP
\-\-replace\-refs {delete\-no\-add, delete\-and\-add, update\-no\-add, update\-or\-add, update\-and\-add, old\-default}
.RS 4
How to handle replace refs (see git\-replace(1))\&. Replace refs can be added during the history rewrite as a way to allow users to pass old commit IDs (from before git\-filter\-repo was run) to git commands and have git know how to translate those old commit IDs to the new (post\-rewrite) commit IDs\&. Also, replace refs that existed before the rewrite can either be deleted or updated\&. The choices to pass to \-\-replace\-refs thus need to specify both what to do with existing refs and what to do with commit rewrites\&. Thus
\fIupdate\-and\-add\fR
means to update existing replace refs, and for any commit rewrite (even if already pointed at by a replace ref) add a new refs/replace/ reference to map from the old commit ID to the new commit ID\&. The default is update\-no\-add, meaning update existing replace refs but do not add any new ones\&. There is also a special
\fIold\-default\fR
option for picking the default used in versions prior to git\-filter\-repo\-2\&.45, namely
\fIupdate\-and\-add\fR
upon the first run of git\-filter\-repo in a repository and
\fIupdate\-or\-add\fR
if running git\-filter\-repo again on a repository\&.
.RE
.PP
\-\-prune\-empty {always, auto, never}
.RS 4
Whether to prune empty commits\&.
\fIauto\fR
(the default) means only prune commits which become empty (not commits which were empty in the original repo, unless their parent was pruned)\&. When the parent of a commit is pruned, the first non\-pruned ancestor becomes the new parent\&.
.RE
.PP
\-\-prune\-degenerate {always, auto, never}
.RS 4
Since merge commits are needed for history topology, they are typically exempt from pruning\&. However, they can become degenerate with the pruning of other commits (having fewer than two parents, having one commit serve as both parents, or having one parent as the ancestor of the other\&.) If such merge commits have no file changes, they can be pruned\&. The default (\fIauto\fR) is to only prune empty merge commits which become degenerate (not which started as such)\&.
.RE
.PP
\-\-no\-ff
.RS 4
Even if the first parent is or becomes an ancestor of another parent, do not prune it\&. This modifies how \-\-prune\-degenerate behaves, and may be useful in projects who always use merge \-\-no\-ff\&.
.RE
.SS "Generic callback code snippets"
.PP
\-\-filename\-callback <function_body>
.RS 4
Python code body for processing filenames; see
the section called \(lqCALLBACKS\(rq\&.
.RE
.PP
\-\-message\-callback <function_body>
.RS 4
Python code body for processing messages (both commit messages and tag messages); see
the section called \(lqCALLBACKS\(rq\&.
.RE
.PP
\-\-name\-callback <function_body>
.RS 4
Python code body for processing names of people; see
the section called \(lqCALLBACKS\(rq\&.
.RE
.PP
\-\-email\-callback <function_body>
.RS 4
Python code body for processing emails addresses; see
the section called \(lqCALLBACKS\(rq\&.
.RE
.PP
\-\-refname\-callback <function_body>
.RS 4
Python code body for processing refnames; see
the section called \(lqCALLBACKS\(rq\&.
.RE
.PP
\-\-file\-info\-callback <function_body>
.RS 4
Python code body for processing the combination of filename, mode, and associated file contents; see <<CALLBACKS>\&. Note that when \-\-file\-info\-callback is specified, any replacements specified by \-\-replace\-text will not be automatically applied; instead, you have control within the \-\-file\-info\-callback to choose which files to apply those transformations to\&.
.RE
.PP
\-\-blob\-callback <function_body>
.RS 4
Python code body for processing blob objects; see
the section called \(lqCALLBACKS\(rq\&.
.RE
.PP
\-\-commit\-callback <function_body>
.RS 4
Python code body for processing commit objects; see
the section called \(lqCALLBACKS\(rq\&.
.RE
.PP
\-\-tag\-callback <function_body>
.RS 4
Python code body for processing tag objects; see
the section called \(lqCALLBACKS\(rq\&. Note that lightweight tags have no tag object and thus are not handled by this callback\&. The only thing you really could do with a lightweight tag is rename it, but for that you should see \-\-refname\-callback instead\&.
.RE
.PP
\-\-reset\-callback <function_body>
.RS 4
Python code body for processing reset objects; see
the section called \(lqCALLBACKS\(rq\&.
.RE
.SS "Sensitive Data Removal"
.PP
\-\-sensitive\-data\-removal, \-\-sdr
.RS 4
This rewrite is intended to remove sensitive data from a repository\&. Gather extra information from the rewrite needed to provide additional instructions on how to clean up other copies\&. This includes:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Fetching all refs, so that if refs outside of branches and tags also reference the sensitive data, they can be cleaned up too
.sp
.if n \{\
.RS 4
.\}
.nf
Note that if you have any local\-only changes (i\&.e\&. un\-pushed
changes) in your repository, on any branch or ref, this fetch step
may discard them\&.  Working in a fresh clone avoids this problem;
see also the \-\-no\-fetch option if you don\*(Aqt want to work with a
fresh clone and you have important local\-only changes\&.
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Tracking and reporting on the first changed commit(s)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Tracking and reporting whether any LFS objects become orphaned by the rewrite, so they can be removed
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Providing additional instructions at the end on how to clean up the repository you cloned from, and other clones of the repo
.RE
.RE
.PP
\-\-no\-fetch
.RS 4
Avoid the "fetch all refs" step with \-\-sensitive\-data\-removal, and thus avoid overwriting local\-only changes in the repository, but at the risk of leaving the sensitive data in other refs in the source repository\&. This option is implied by \-\-partial or any flag that implies \-\-partial\&.
.RE
.SS "Location to filter from/to"
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Specifying alternate source or target locations implies \-\-partial\&. However, unlike normal uses of \-\-partial, this doesn\(cqt risk mixing old and new history since the old and new histories are in different repositories\&.
.sp .5v
.RE
.PP
\-\-source <source>
.RS 4
Git repository to read from
.RE
.PP
\-\-target <target>
.RS 4
Git repository to overwrite with filtered history
.RE
.SS "Miscellaneous options"
.PP
\-\-help, \-h
.RS 4
Show a help message and exit\&.
.RE
.PP
\-\-force, \-f
.RS 4
Ignore fresh clone checks and rewrite history (an irreversible operation, especially since it by default ends with an immediate pruning of reflogs and old objects)\&. See
the section called \(lqFRESH CLONE SAFETY CHECK AND \-\-FORCE\(rq\&. Note that when cloning repos on a local filesystem, it is better to pass
\fB\-\-no\-local\fR
to git clone than passing
\fB\-\-force\fR
to git\-filter\-repo\&.
.RE
.PP
\-\-partial
.RS 4
Do a partial history rewrite, resulting in the mixture of old and new history\&. This disables rewriting refs/remotes/origin/* to refs/heads/*, disables removing of the
\fIorigin\fR
remote, disables removing unexported refs, disables expiring the reflog, and disables the automatic post\-filter gc\&. Also, this modifies \-\-tag\-rename and \-\-refname\-callback options such that instead of replacing old refs with new refnames, it will instead create new refs and keep the old ones around\&. Use with caution\&.
.RE
.PP
\-\-refs <refs+>
.RS 4
Limit history rewriting to the specified refs\&. Implies \-\-partial\&. In addition to the normal caveats of \-\-partial (mixing old and new history, no automatic remapping of refs/remotes/origin/* to refs/heads/*, etc\&.), this also may cause problems for pruning of degenerate empty merge commits when negative revisions are specified\&.
.RE
.PP
\-\-dry\-run
.RS 4
Do not change the repository\&. Run
\fBgit\fR
\fBfast\-export\fR
and filter its output, and save both the original and the filtered version for comparison\&. This also disables rewriting commit messages due to not knowing new commit IDs and disables filtering of some empty commits due to inability to query the fast\-import backend\&.
.RE
.PP
\-\-debug
.RS 4
Print additional information about operations being performed and commands being run\&. (If used together with \-\-dry\-run, shows extra information about what would be run)\&.
.RE
.PP
\-\-stdin
.RS 4
Instead of running
\fBgit\fR
\fBfast\-export\fR
and filtering its output, filter the fast\-export stream from stdin\&. The stdin must be in the expected input format (e\&.g\&. it needs to include original\-oid directives)\&.
.RE
.PP
\-\-quiet
.RS 4
Pass \-\-quiet to other git commands called\&.
.RE
.SH "OUTPUT"
.sp
Every time filter\-repo is run, files are created in the \fB\&.git/filter\-repo/\fR directory\&. These files are updated or overwritten on every run\&.
.SS "Commit map"
.sp
The \fB$GIT_DIR/filter\-repo/commit\-map\fR file contains a mapping of how all commits were (or were not) changed\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A header is the first line with the text "old" and "new"
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Commit mappings are in no particular order
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
All commits in range of the rewrite will be listed, even commits that are unchanged (e\&.g\&. because the commit pre\-dated when files the filtering operation are removing were introduced to the repo)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An all\-zeros hash, or null SHA, represents a non\-existent object\&. When in the "new" column, this means the commit was removed entirely\&.
.RE
.SS "Reference map"
.sp
The \fB$GIT_DIR/filter\-repo/ref\-map\fR file contains a mapping of which local references were (or were not) changed\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
A header is the first line with the text "old", "new" and "ref"
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Reference mappings are sorted by ref
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
An all\-zeros hash, or null SHA, represents a non\-existent object\&. When in the "new" column, this means the ref was removed entirely\&.
.RE
.SS "Changed References"
.sp
The \fB$GIT_DIR/filter\-repo/changed\-refs\fR file contains a list of refs that were changed\&.
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
No header is provided
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Lists the subsets of refs from ref\-map for which old != new
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
While unnecessary since this provides no new information over ref\-map, it does make it easier to quickly determine which refs were changed by the rewrite\&.
.RE
.SS "First Changed Commits"
.sp
The \fB$GIT_DIR/filter\-repo/first\-changed\-commits\fR contains a list of the first commit(s) changed by the filtering operation\&. These are the commits that got rewritten and which had no parents that were also rewritten\&.
.sp
So, for example if you had commits A1\-B1\-C1\-D1\-E1 before running git\-filter\-repo, and afterward you had commits A1\-B2\-C2\-D2\-E2 then the First Changed Commits file would contain just one line, which would be the hash of B2\&.
.sp
In most cases, there will only be one commit listed, but if you had multiple root commits or a non\-linear history where the commits on those diverging histories were the first ones modified, then there could be multiple first changed commits and they will each be listed on separate lines\&.
.SS "Already Ran"
.sp
The \fB$GIT_DIR/filter\-repo/already_ran\fR file contains a file recording that git\-filter\-repo has been run\&. When this file is present, future runs will be treated as an extension of the previous filtering operation\&.
.sp
Concretely, this means: * The "Fresh Clone" check is bypassed
.sp
.if n \{\
.RS 4
.\}
.nf
This is done because past runs would cause the repository to no longer
look like a fresh clone, and thus fail the fresh clone check, but doing
filtering via multiple invocations of git\-filter\-repo is an intended
and support usecase\&.  You already passed or bypassed the "Fresh Clone"
check on your initial run\&.
.fi
.if n \{\
.RE
.\}
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The commit\-map and ref\-map files above will be updated rather than simply rewritten\&.
.sp
.if n \{\
.RS 4
.\}
.nf
In other words, if the first filter\-repo invocation rewrote commit
A to commit B, and the second filter\-repo invocation rewrite
commit B to commit C, then the second run would have an "A C"
entry rather than a "B C" entry for the changed commit\&.
.fi
.if n \{\
.RE
.\}
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The first changed commit(s) (reported When using the \-\-sensitive\-data\-removal option) will be the first original commit modified, not the first intermediate commit modified\&.
.sp
.if n \{\
.RS 4
.\}
.nf
In more detail, if the repository original had the following commits:
   A1\-B1\-C1\-D1\-E1
and the first invocation of filter\-repo changed this to
   A1\-B1\-C2\-D2\-E2
then the first run would report "C1" as the first changed commit\&.  If
a second filter\-repo run further changed this to
   A1\-B1\-C2\-D3\-E3
then it would report "C1" as the first changed commit, not "D2",
because it is comparing to the original commits rather than the
intermediate ones\&.
.fi
.if n \{\
.RE
.\}
.RE
.sp
However, if the already_ran file exists but is older than 1 day when they invoke git\-filter\-repo, the user will be prompted for whether the new run should be considered a continuation of the previous run\&. If they do not answer in the affirmative, then the above three bullets will not apply\&. This prompt exists because users might do a history rewrite in a repository, forget about it and leave the $GIT_DIR/filter\-repo directory around, and then some months or years later need to do another rewrite\&. If commits have been made public and shared from the previous rewrite, then the next filter\-repo run should not be considered a continuation of the previous filtering run\&.
.SS "Original LFS Objects"
.sp
When running with the \-\-sensitive\-data\-removal flag, and LFS is in use by the repository, the \fB$GIT_DIR/filter\-repo/original_lfs_objects\fR contains a list of LFS objects referenced by the repository before the rewrite, in sorted order\&.
.SS "Orphaned LFS Objects"
.sp
When running with the \-\-sensitive\-data\-removal flag, and LFS is in use by the repository, the \fB$GIT_DIR/filter\-repo/orphaned_lfs_objects\fR contains a list of LFS objects that used to be referenced by the repository but no longer are after git\-filter\-repo has run\&. Objects appear in sorted order\&.
.SH "FRESH CLONE SAFETY CHECK AND \-\-FORCE"
.sp
Since filter\-repo does irreversible rewriting of history, it is important to avoid making changes to a repo for which the user doesn\(cqt have a good backup\&. The primary defense mechanism is to simply educate users and rely on them to be good stewards of their data; thus there are several warnings in the documentation about how filter repo rewrites history\&.
.sp
However, as a service to users, we would like to provide an additional safety check beyond the documentation\&. There isn\(cqt a good way to check if the user has a good backup, but we can ask a related question that is an imperfect but quite reasonable proxy: "Is this repository a fresh clone?" Unfortunately, that is also a question we can\(cqt get a perfect answer to; git provides no way to answer that question\&. However, there are approximately a dozen things that I found that seem to always be true of brand new clones (assuming they are either clones of remote repositories or are made with the \fB\-\-no\-local\fR flag), and I check for all of those\&.
.sp
These checks can have both false positives and false negatives\&. Someone might have a perfectly good backup of their repo without it actually being a fresh clone \(em but there\(cqs no way for filter\-repo to know that\&. Conversely, someone could look at all things that filter\-repo checks for in its safety checks and then just tweak their non\-backed\-up repository to satisfy those conditions (though it would take a fair amount of effort, and it\(cqs astronomically unlikely that a repo that isn\(cqt a fresh clone randomly happens to match all the criteria)\&. In practice, the safety checks filter\-repo uses seem to be really good at avoiding people accidentally running filter\-repo on a repository that they shouldn\(cqt be running it on\&. It even caught me once when I did mean to run filter\-repo but was in a different directory than I thought I was\&.
.sp
In short, it\(cqs perfectly fine to use \(oq\-\-force` to override the safety checks as long as you\(cqre okay with filter\-repo irreversibly rewriting the contents of the current repository\&. It is a really bad idea to get in the habit of always specifying \fB\-\-force\fR; if you do, one day you will run one of your commands in the wrong directory like I did, and you won\(cqt have the safety check anymore to bail you out\&. Also, it is definitely NOT okay to recommend \fB\-\-force\fR on forums, Q&A sites, or in emails to other users without first carefully explaining that \fB\-\-force\fR means putting your repositories\(cq data at risk\&. I am especially bothered by people who suggest the flag when it clearly is NOT needed; they are needlessly putting other peoples\*(Aq data at risk\&.
.SH "VERSATILITY"
.sp
filter\-repo has a hierarchy of capabilities on the spectrum from easy to use convenience flags that perform pre\-defined types of filtering, to choices that provide lots of flexibility in controlling how filtering occurs\&. This spectrum includes the following:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Convenience flags making common types of history rewriting simple (e\&.g\&. \-\-path, \-\-strip\-blobs\-bigger\-than, \-\-replace\-text, \-\-mailmap)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Options which are shorthand for others or which provide greater control than others (e\&.g\&. \-\-subdirectory\-filter could just be written using both a path selection (\-\-path) and a path rename (\-\-path\-rename) filter; \-\-paths\-from\-file can handle all other \-\-path* options and more such as regex renaming of paths)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Generic python callbacks for handling a certain type of data (the filename, message, name, email, and refname callbacks)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Generic python callbacks for handling fundamental git objects, allowing greater control over the combination of data types the object holds (the commit, tag, blob, and reset callbacks)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The ability to import filter\-repo as a module in a python program and use its classes and functions for even greater control and flexibility while still leveraging lots of basic capabilities\&. One can even use this to write new tools with a completely different interface\&.
.RE
.sp
For more information about callbacks, see the section called \(lqCALLBACKS\(rq\&. For examples on writing python programs that import filter\-repo as a module to create new history rewriting tools, look at the contrib/filter\-repo\-demos/ directory\&. That directory includes, among other examples, a reimplementation of git\-filter\-branch which is faster than git\-filter\-branch, and a reimplementation of BFG Repo Cleaner with several bug fixes and new features\&.
.SH "DISCUSSION"
.sp
Using filter\-repo is relatively simple, but rewriting history is part of a larger discussion in terms of collaboration\&. When you rewrite history, the old and new histories are no longer compatible; if you push this history somewhere for others to view, it will look as though you\(cqve done a rebase of all branches and tags\&. Make sure you are familiar with the "RECOVERING FROM UPSTREAM REBASE" section of \fBgit-rebase\fR(1) (and in particular, "The hard case") before proceeding, in addition to this section\&.
.sp
Steps to use git\-filter\-repo as part of the bigger picture of doing a history rewrite are roughly as follows:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Create a clone of your repository\&. You may pass
\fB\-\-bare\fR
or
\fB\-\-mirror\fR
to
\fBgit\fR
\fBclone\fR, if you prefer\&. You should pass
\fB\-\-no\-local\fR
if the repository you are cloning from is on the local filesystem\&. Avoid other flags; some might confuse the fresh clone check, and others could cause parts of the data to be missing that are needed for the rewrite\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
(Optional) Run
\fBgit\fR
\fBfilter\-repo\fR
\fB\-\-analyze\fR\&. This will create a directory of reports mentioning multiple things: (a) paths that have existed over time in your repo, (b) renames that have occurred in your repo and (c) sizes of objects aggregated by path/directory/extension/blob\-id\&. This information may be useful in choosing how to filter your repo\&. It can also be useful to re\-run \-\-analyze after filtering to verify the changes look correct\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
Before rewriting the history of your local copy with git\-filter\-repo, determine where you will push the rewritten history to when you are done\&. In the special case that you are trying to remove sensitive data from an existing repository, you will want to push it back where you cloned from, as well as clean up all other clones/copies of the repo\&. If you will be pushing back to the repository you cloned from, you will want to use the \-\-sensitive\-data\-removal option and see the Sensitive Data Removal section below\&. In most cases not dealing with sensitive data removal, you will want to push to a new repo, because:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Even after you rewrite history and push it back, other people who previously cloned from the original repo will have the old history\&. If they simply run
\fBgit\fR
\fBpull\fR
&&
\fBgit\fR
\fBpush\fR, it will merge the unrewritten history with the new, resulting in what looks like two copies of each commit involved in your rewrite \(em a new copy of each commit which has the cleanups you made, and an old copy of each commit that has not been cleaned up \(em being merged together\&. That means everything you carefully worked to remove from the repository has been pushed back\&. You\(cqre more likely to succeed in making sure they don\(cqt re\-push the unclean data if you just give them a new repository URL and tell them to reclone\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Rewriting history will rewrite tags; those who have already downloaded tags will not get the updated tags even if they specify
\fB\-\-tags\fR
to
\fBgit\fR
\fBfetch\fR
or
\fBgit\fR
\fBpull\fR
(see the "On Re\-tagging" section of
\fBgit-tag\fR(1))\&. Every user trying to use an existing clone will have to forcibly delete all tags they already downloaded
\fIbefore\fR
re\-fetching them; it may be easier for them to just re\-clone, which they are more likely to do with a new clone URL\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Rewriting history may delete some refs (e\&.g\&. branches that only had files that you wanted excised from history); unless you run git push with the
\fB\-\-mirror\fR
or
\fB\-\-prune\fR
options, those refs will continue to exist on the server\&. If folks then merge these branches into others, then people have started mixing old and new history\&. If users had already cloned these branches, removing them from the server isn\(cqt enough; you need all users to delete any local branches based on these refs and run fetch with the
\fB\-\-prune\fR
option as well\&. Simply re\-cloning from a new URL is easier\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The server may not allow you to force push over some refs\&. For example, code review systems may have special ref namespaces (e\&.g\&. refs/changes/, refs/pull/, refs/merge\-requests/) that they have locked down, and you\(cqll need to somehow prevent users from merging those locked\-down (and thus not cleaned up) histories with your cleaned\-up history\&. Every software code review system handles this differently (see the sensitive data removal section for some links)\&.
.RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Run filter\-repo with your desired filtering options\&. Many examples are given in the
the section called \(lqEXAMPLES\(rq
section\&. For more complex cases, note that doing the filtering in multiple steps (by running multiple filter\-repo invocations in a sequence) is supported\&. If anything goes wrong here, simply delete your clone and restart\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
Push your new repository to its new home (note that refs/remotes/origin/* will have been moved to refs/heads/* as the first part of filter\-repo, so you can just deal with normal branches instead of remote tracking branches)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
(Optional) Some additional considerations
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
filter\-repo has a \-\-replace\-refs option to allow creating replace refs (see
\fBgit-replace\fR(1)) for each rewritten commit ID, allowing you to use old (unabbreviated) commit hashes in the git command line to refer to the newly rewritten commits\&. If you want to use these replace refs, manually push them to the relevant clone URL and tell users to manually fetch them (e\&.g\&. by adjusting their fetch refspec,
\fBgit\fR
\fBconfig\fR
\fB\-\-add\fR
\fBremote\&.origin\&.fetch\fR
\fB+refs/replace/\fR*:refs/replace/*)\&. Sadly, replace refs are not yet widely understood; projects like jgit and libgit2 do not support them and existing repository managers (e\&.g\&. Gerrit, GitHub, GitLab) do not yet understand replace refs\&. Thus one can\(cqt use old commit hashes within the UI of these other systems\&. This may change in the future, but replace refs at least help users locally within the git command line interface\&. Also, be aware that commit\-graphs are excessively cautious around replace refs and just turn off entirely if any are present, so after enough time has passed that old commit IDs become less relevant, users may want to locally delete the replace refs to regain the speedups from commit\-graphs\&.
.RE
.RE
.SS "Why is my origin removed?"
.sp
When you rewrite history, all commit IDs (starting with the first one where changes are made) are modified\&. Even if you think you didn\(cqt change an intermediate commit, the fact that you changed any of its ancestors is also a change that counts and will cause a commit\(cqs ID to change as well\&. It is unfortunately all\-too\-easy for yourself or someone else to accidentally merge the old ugly history you were trying to rewrite with the new history, resulting in not only the old ugly history returning but getting you "two copies" of each commit (both an original commit and a cleaned\-up alternative), and thus doubling the number of commits in your repository\&. In short, you end up with an even bigger mess to clean up than you started with\&.
.sp
This happens frequently to people using \fBgit\fR \fBfilter\-branch\fR or \fBBFG\fR \fBrepo\fR \fBcleaner\fR, and can happen to folks using \fBgit\fR \fBfilter\-repo\fR if they insist on pushing back to the original repo\&. Example ways you can get such an even uglier history include:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
at the command line (of another clone of the same repo from before the cleanup):
\fBgit\fR
\fBpull\fR
&&
\fBgit\fR
\fBpush\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
in a software forge: "reopen old Pull\-Request/Merge\-Request/Code\-Review and hit the merge/submit button"
.RE
.sp
Removing the \fBorigin\fR remote and suggesting people push to a new repo (and ensuring they tell others to clone the new repo) is usually a good forcing function to avoid these problems\&. But, if people really want to push to the original repository despite these warnings, it is trivial to do so; simply run:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fBgit\fR
\fBremote\fR
\fBadd\fR
\fBorigin\fR
\fB$ORIGINAL_CLONE_URL\fR
.RE
.sp
and then you can push (e\&.g\&. \fBgit\fR \fBpush\fR \fB\-\-force\fR \fB\-\-branches\fR \fB\-\-tags\fR \fB\-\-prune\fR)\&. Since removing the origin url is such a cheap way to potentially prevent big messes, and it\(cqs so easy to work around for those that really do want to push back over the original history, removing the origin url is a great safety measure that I employ\&.
.sp
One final warning if you really want to push back to the original repo: see the next section on sensitive data removals\&. Those are the steps needed when pushing back to the original repo; they are so involved that I assume they are only worth it when sensitive data is involved, but you can choose to follow them for other kinds of rewrites too\&.
.SS "Sensitive Data Removals"
.sp
Sensitive data removals are a specialized type of history rewrite\&. While it is always very problematic to mix the cleaned\-up history with the non\-cleaned\-up history, for sensitive data removals it is also bad to allow others to continue to view/clone/fetch the non\-cleaned\-up history at all; users often need to try to expunge the old history as well\&.
.sp
Note that if the sensitive data under consideration is a token/password/credential/secret (as is often the case), then it is important that you revoke and rotate that credential first\&. Once the credential is revoked or rotated, it can no longer be used for access\&. Revoking/rotating may resolve your problem without resorting to the heavy\-handed action of rewriting and purging history\&.
.sp
For sensitive data removal history rewrites, there are three high\-level steps:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Rewrite the repository locally, using git\-filter\-repo
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Make sure other copies are cleaned up, including:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
the server you cloned from
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
other clones that exist, such as ones your colleagues made
.RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Prevent repeats and avoid future sensitive data spills
.RE
.sp
Each will be discussed in greater detail below\&.
.sp
One important thing to note, though, is that others working on the same repository should be instructed to stop while you do the cleanup; if they continue development during your cleanup, you\(cqll likely be forced to either discard their changes or start over on your cleanup\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBRewrite the repository locally, using git-filter-repo\fR
.RS 4
.sp
The first step is to rewrite a copy of your repository locally using git\-filter\-repo\&. The exact commands to run will differ based on where in your repository the sensitive data is found, but some general tips:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Use the \-\-sensitive\-data\-removal flag\&. It will provide additional information useful for the other steps\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If the sensitive data is the entirety of one or more files, and no version of those files from history needs to be kept in your repository, the \-\-invert\-paths flag together with one or more \-\-path arguments may come in handy\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If the sensitive data is just a string found within one or more files and you want to replace that sensitive string with something else while leaving the rest of the file(s) intact, the \-\-replace\-text option may come in handy\&.
.RE
.sp
After rewriting the history locally, make sure to inspect it to ensure the sensitive data has been removed\&. Some commands that might be handy for checking are:
.sp
.if n \{\
.RS 4
.\}
.nf
git log \-\-all \-\-name\-status \-\- ${PROBLEMATIC_FILE1} ${PROBLEMATIC_FILE2}
.fi
.if n \{\
.RE
.\}
.sp
.sp
or
.sp
.if n \{\
.RS 4
.\}
.nf
git log \-S"${PROBLEMATIC_STRING}" \-\-all \-p \-\-
.fi
.if n \{\
.RE
.\}
.sp
.sp
If either of these commands turn up more sensitive data, then run additional git\-filter\-repo commands to clean up the necessary data before proceeding\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMake sure other copies are cleaned up: primary server\fR
.RS 4
.sp
Cleaning up the repository you cloned from requires force pushing your rewritten history over the original\&. You need to force push all refs, not just your current branch\&. You can use the following command to do so (read the bulleted list right after this command before running it):
.sp
.if n \{\
.RS 4
.\}
.nf
git push \-\-force \-\-mirror origin
.fi
.if n \{\
.RE
.\}
.sp
.sp
Several comments on this command:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If any of your colleagues have pushed any changes since you started, this force push command will discard their changes\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
This force push is likely to fail to push some refs, since most forges (Gerrit, GitHub, GitLab, etc\&.) prevent you from updating some refs (e\&.g\&.
\fBrefs/changes/\fR*,
\fBrefs/pull/\fR*,
\fBrefs/merge\-requests/\fR*)\&. You will need to follow the directions from those forges to get the remaining refs updated or deleted, and a garbage collection to be triggered on their end\&. Some examples: (\m[blue]\fBGitLab\(cqs docs on reducing repository size\fR\m[]\&\s-2\u[1]\d\s+2, or
\m[blue]\fBthe "Fully removing the data from GitHub" section of GitHub\(cqs docs\fR\m[]\&\s-2\u[2]\d\s+2)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If you passed the
\fB\-\-no\-fetch\fR
option to git\-filter\-repo (or implied it with another option), you will either need to (1) drop the
\fB\-\-mirror\fR
option and figure out which refs or refspecs to push on your own, or (2) use the
\fB\-\-mirror\fR
option and risk deleting any refs you didn\(cqt fetch\&. Further, if you lacked some refs the server had which included the sensitive data in their history, then your only options at this point to actually clean up the sensitive data from the server are to either redo your rewrite from scratch (and make sure to get the relevant refs included this time) or delete those refs on the server\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Yes, I know that \-\-mirror implies \-\-force and is unnecessary\&. I included \-\-force anyway as a visual reminder to readers that this is going to overwrite changes on the server\&.
.RE
.sp
Also, if any LFS objects were orphaned by your rewrite, those objects likely contain sensitive data and need to be deleted/purged from the LFS server\&. You\(cqll have to ask the maintainer of the LFS server you are using for how to delete/purge those on the server\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBMake sure other copies are cleaned up: clones of colleagues\fR
.RS 4
.sp
After you have cleaned up the server, the easiest way to clean up other clones is to make everyone delete their existing clones and reclone\&.
.sp
If that isn\(cqt an option, then you will need to proceed carefully because a simple \fBgit\fR \fBpull\fR && \fBgit\fR \fBpush\fR from any other clone will recontaminate the main repository and make the mess even harder to clean up\&. To avoid this, before pushing from any other clone, you\(cqll need to have them clean up their copy, as detailed below\&.
.sp
First, though, let me note that you should \fBnot\fR have other developers try to cleanup their clone by running the same \fBgit\-filter\-repo\fR commands that you ran\&. While that sometimes may happen to work, it is not reliable in general\&. Running the same \fBgit\-filter\-repo\fR commands, even if identical, can result in them getting new hashes for commits that are different than your new hashes, and you\(cqll end up with a mess involving two or more copies of every commit\&.
.sp
Instead developers with other clones of the repository should run through the following steps to clean up their copy if they are unwilling to discard their copy and reclone:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
delete all tags and run
\fBgit\fR
\fBfetch\fR
\fB\-\-prune\fR
\fB\-\-tags\fR\&. Running the fetch command without deleting tags first will result in the old tags being kept, which will keep the sensitive data\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
rebase any changes they have on any branch (or other ref) on top of the new history\&. See the "RECOVERING FROM UPSTREAM REBASE" section of
\fBgit-rebase\fR(1)
(and in particular, "The hard case") for instructions\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
run a few steps to clean out the pre\-rebase history (note that the first step drops all reflogs including all stash entries\&. That\(cqs a high cost, but needed to clean up the sensitive data):
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
git reflog expire \-\-expire=now \-\-all
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
git gc \-\-prune=now
.RE
.RE
.sp
Once these steps are complete, you also need to verify that the clone no longer contains any sensitive data (it is really easy to miss something, which puts you at risk of recontaminating other repositories with the sensitive data)\&. You can do so by running:
.sp
.if n \{\
.RS 4
.\}
.nf
git cat\-file \-t ${HASH_OF_FIRST_CHANGED_COMMIT}
.fi
.if n \{\
.RE
.\}
.sp
.sp
Where \fB$\fR{HASH_OF_FIRST_CHANGED_COMMIT} was printed by git\-filter\-repo at the end of its run (if there was more than one "first changed commit", run this command multiple times, with each commit hash)\&. If this command returns a fatal error, then the commit has correctly been removed from this repository\&. If it responds with "commit", then the object still exists and you need to re\-delete tags, re\-rebase all necessary branches/refs, and re\-expire reflogs and redo the gc\&. If you are curious about which branches or refs were the problematic ones holding on to \fB$\fR{HASH_OF_FIRST_CHANGED_COMMIT}, then presuming you did the reflog expire and gc jobs above, the following command should help you find the problematic branches/refs:
.sp
.if n \{\
.RS 4
.\}
.nf
git for\-each\-ref \-\-contains ${HASH_OF_FIRST_CHANGED_COMMIT}
.fi
.if n \{\
.RE
.\}
.sp
.sp
Also, remember, the cat\-file command needs to come back with a fatal error for every \fB$\fR{HASH_OF_FIRST_CHANGED_COMMIT} involved if you have more than one\&.
.sp
After this is all done, then if any LFS objects were orphaned by the rewrite (which again, you will be told if you use the \-\-sensitive\-data\-removal option when you run git\-filter\-repo), then you also need to remove those LFS objects\&. Look for them a couple directories under \&.git/lfs/objects/, and delete them\&.
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBPrevent repeats and avoid future sensitive data spills\fR
.RS 4
.sp
There are several measures you can take to help avoid repeat problems\&. Not all may be applicable for your case, but the more that are, the more likely you can avoid problems\&.
.sp
For dealing with the existing sensitive data spill:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Since it is so easy to re\-contaminate the repository you cloned from (it merely takes a colleague to run
\fBgit\fR
\fBpull\fR
&&
\fBgit\fR
\fBpush\fR
from their clone that was created before your cleanup), take extra vigilance in performing the clean ups steps above for other clones to ensure they have all been cleaned up\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If you have a central repository everyone pushes to, look into methods to ban the First Changed Commit(s) from being (re\-)pushed to your repository\&. Sadly, few repository managers currently have such a built\-in capability (see Gerrit\(cqs ban\-commit ability for one such example at
\m[blue]\fBhttps://gerrit\-review\&.googlesource\&.com/Documentation/cmd\-ban\-commit\&.html\fR\m[]), but a few may allow you to write your own pre\-receive hooks that reject pushes containing these bad commits\&. (Pro\-tip for writing such a pre\-receive hook: use
\fBgit\fR
\fBcat\-file\fR
\fB\-t\fR
\fB$\fR{BAD_COMMIT} as a cheap check before checking if any revision range between
\fI<old\-oid>\fR
and
\fI<new\-oid>\fR
contains
\fB$\fR{BAD_COMMIT})
.RE
.sp
Steps to help avoid other future sensitive data spills:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If sensitive data is likely to appear within certain filenames that should not be tracked in git at all, then add those filenames to \&.gitignore to reduce the risk that others accidentally add them\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Avoid hardcoding secrets in code\&. Use environment variables, configuration management tools, or secrets management services like Azure Key Vault, AWS Secrets Manager, or HashiCorp Vault to manage and inject secrets at runtime\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Create a pre\-commit hook to check for sensitive data before it is committed or pushed anywhere, or use a well\-known tool in a pre\-commit hook like git\-secrets or gitleaks\&.
.RE
.RE
.SH "EXAMPLES"
.SS "Path based filtering"
.sp
To only keep the \fIREADME\&.md\fR file plus the directories \fIguides\fR and \fItools/releases/\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path README\&.md \-\-path guides/ \-\-path tools/releases
.fi
.if n \{\
.RE
.\}
.sp
.sp
Directory names can be given with or without a trailing slash, and all filenames are relative to the toplevel of the repo\&. To keep all files except these paths, just add \fB\-\-invert\-paths\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path README\&.md \-\-path guides/ \-\-path tools/releases \-\-invert\-paths
.fi
.if n \{\
.RE
.\}
.sp
.sp
If you want to have both an inclusion filter and an exclusion filter, just run filter\-repo multiple times\&. For example, to keep the src/main subdirectory but exclude files under src/main named \fIdata\fR, run:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path src/main/
git filter\-repo \-\-path\-glob \*(Aqsrc/*/data\*(Aq \-\-invert\-paths
.fi
.if n \{\
.RE
.\}
.sp
.sp
Note that the asterisk (*) will match across multiple directories, so the second command would remove e\&.g\&. src/main/org/whatever/data\&. Also, the second command by itself would also remove e\&.g\&. src/not\-main/foo/data, but since src/not\-main/ was removed by the first command, that\(cqs not an issue\&. Also, the use of quotes around the asterisk is sometimes important to avoid glob expansion by the shell\&.
.sp
You can also select paths by regular expression (see \m[blue]\fBhttps://docs\&.python\&.org/3/library/re\&.html#regular\-expression\-syntax\fR\m[])\&. For example, to only include files from the repo whose name is in the format YYYY\-MM\-DD\&.txt and is found at least two subdirectories deep:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path\-regex \*(Aq^\&.*/\&.*/[0\-9]{4}\-[0\-9]{2}\-[0\-9]{2}\&.txt$\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
If you want two directories to be renamed (and maybe merged if both are renamed to the same location), use \-\-path\-rename; for example, to rename both \fIcmds/\fR and \fIsrc/scripts/\fR to \fItools/\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path\-rename cmds:tools \-\-path\-rename src/scripts/:tools/
.fi
.if n \{\
.RE
.\}
.sp
.sp
As with \fB\-\-path\fR, directories can be specified with or without a trailing slash for \fB\-\-path\-rename\fR\&.
.sp
If you do a \fB\-\-path\-rename\fR to something that was already in use, it will be silently overwritten\&. However, if you try to rename multiple files to the same location (e\&.g\&. src/scripts/run_release\&.sh and cmds/run_release\&.sh both existed and had different content with the renames above), then you will be given an error\&. If you have such a case, you may want to add another rename command to move one of the paths somewhere else where it won\(cqt collide:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path\-rename cmds/run_release\&.sh:tools/do_release\&.sh \e
                \-\-path\-rename cmds/:tools/ \e
                \-\-path\-rename src/scripts/:tools/
.fi
.if n \{\
.RE
.\}
.sp
.sp
Also, \fB\-\-path\-rename\fR brings up ordering issues; all path arguments are applied in order\&. Thus, a command like
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path\-rename sources/:src/main/ \-\-path src/main/
.fi
.if n \{\
.RE
.\}
.sp
.sp
would make sense but reversing the two arguments would not (src/main/ is created by the rename so reversing the two would give you an empty repo)\&. Also, note that the rename of cmds/run_release\&.sh a couple examples ago was done before the other renames\&.
.sp
Note that path renaming does not do path filtering, thus the following command
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path src/main/ \-\-path\-rename tools/:scripts/
.fi
.if n \{\
.RE
.\}
.sp
.sp
would not result in the tools or scripts directories being present, because the single filter selected only src/main/\&. It\(cqs likely that you would instead want to run:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-path src/main/ \-\-path tools/ \-\-path\-rename tools/:scripts/
.fi
.if n \{\
.RE
.\}
.sp
.sp
If you prefer to filter based solely on basename, use the \fB\-\-use\-base\-name\fR flag (though this is incompatible with \fB\-\-path\-rename\fR)\&. For example, to only include README\&.md and Makefile files from any directory:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-use\-base\-name \-\-path README\&.md \-\-path Makefile
.fi
.if n \{\
.RE
.\}
.sp
.sp
If you wanted to delete all \&.DS_Store files in any directory, you could either use:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-invert\-paths \-\-path \*(Aq\&.DS_Store\*(Aq \-\-use\-base\-name
.fi
.if n \{\
.RE
.\}
.sp
.sp
or
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-invert\-paths \-\-path\-glob \*(Aq*/\&.DS_Store\*(Aq \-\-path \*(Aq\&.DS_Store\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
(the \fB\-\-path\-glob\fR isn\(cqt sufficient by itself as it might miss a toplevel \&.DS_Store file; further while something like \fB\-\-path\-glob\fR \*(Aq*\&.DS_Store\*(Aq would workaround that problem it would also grab files named \fBfoo\&.DS_Store\fR or \fBbar/baz\&.DS_Store\fR)
.sp
Finally, see also the \fB\-\-filename\-callback\fR from the section called \(lqCALLBACKS\(rq\&.
.SS "Filtering based on many paths"
.sp
If you have a long list of files, directories, globs, or regular expressions to filter on, you can stick them in a file and use \fB\-\-paths\-from\-file\fR; for example, with a file named stuff\-i\-want\&.txt with contents of
.sp
.if n \{\
.RS 4
.\}
.nf
# Blank lines and comment lines are ignored\&.
# Examples similar to \-\-path:
README\&.md
guides/
tools/releases

# An example that is like \-\-path\-glob:
glob:*\&.py

# An example that is like \-\-path\-regex:
regex:^\&.*/\&.*/[0\-9]{4}\-[0\-9]{2}\-[0\-9]{2}\&.txt$

# An example of renaming a path
tools/==>scripts/

# An example of using a regex to rename a path
regex:(\&.*)/([^/]*)/([^/]*)\e\&.text$==>\e2/\e1/\e3\&.txt
.fi
.if n \{\
.RE
.\}
.sp
.sp
then you could run
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-paths\-from\-file stuff\-i\-want\&.txt
.fi
.if n \{\
.RE
.\}
.sp
.sp
to get a repo containing only the toplevel README\&.md file, the guides/ and tools/releases/ directories, all python files, files whose name was of the form YYYY\-MM\-DD\&.txt at least two subdirectories deep, and would rename tools/ to scripts/ and rename files like foo/bar/baz\&.text to bar/foo/baz\&.txt\&. Note the special line prefixes of \fBglob:\fR and \fBregex:\fR and the special string \fB==\fR> denoting renames\&.
.sp
Sometimes you have a way of easily generating all the files you want\&. For example, if you know that none of the currently tracked files have any newlines or special characters in them (see core\&.quotePath from \fBgit\fR \fBconfig\fR \fB\-\-help\fR) so that \fBgit\fR \fBls\-files\fR would print all files literally one per line, and you knew that you wanted to keep only the files that are currently tracked (thus deleting from all commits in history any files that only appear on other branches or that only appear in older commits), then you could use a pair of commands such as
.sp
.if n \{\
.RS 4
.\}
.nf
git ls\-files >\&.\&./paths\-i\-want\&.txt
git filter\-repo \-\-paths\-from\-file \&.\&./paths\-i\-want\&.txt
.fi
.if n \{\
.RE
.\}
.sp
.sp
Similarly, you could use \-\-paths\-from\-file to delete many files\&. For example, you could run \fBgit\fR \fBfilter\-repo\fR \fB\-\-analyze\fR to get reports, look in one such as \&.git/filter\-repo/analysis/path\-deleted\-sizes\&.txt and copy all the filenames into a file such as /tmp/files\-i\-dont\-want\-anymore\&.txt and then run
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-invert\-paths \-\-paths\-from\-file /tmp/files\-i\-dont\-want\-anymore\&.txt
.fi
.if n \{\
.RE
.\}
.sp
.sp
to delete them all\&.
.SS "Directory based shortcuts"
.sp
Let\(cqs say you had a directory structure like the following:
.sp
.if n \{\
.RS 4
.\}
.nf
module/
   foo\&.c
   bar\&.c
otherDir/
   blah\&.config
   stuff\&.txt
zebra\&.jpg
.fi
.if n \{\
.RE
.\}
.sp
If you wanted just the module/ directory and you wanted it to become the new root so that your new directory structure looked like
.sp
.if n \{\
.RS 4
.\}
.nf
foo\&.c
bar\&.c
.fi
.if n \{\
.RE
.\}
.sp
then you could run:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-subdirectory\-filter module/
.fi
.if n \{\
.RE
.\}
.sp
.sp
If you wanted all the files from the original repo, but wanted to move everything under a subdirectory named my\-module/, so that your new directory structure looked like
.sp
.if n \{\
.RS 4
.\}
.nf
my\-module/
   module/
      foo\&.c
      bar\&.c
   otherDir/
      blah\&.config
      stuff\&.txt
   zebra\&.jpg
.fi
.if n \{\
.RE
.\}
.sp
then you would instead run run
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-to\-subdirectory\-filter my\-module/
.fi
.if n \{\
.RE
.\}
.sp
.SS "Content based filtering"
.sp
If you want to filter out all files bigger than a certain size, you can use \fB\-\-strip\-blobs\-bigger\-than\fR with some size (K, M, and G suffixes are recognized), e\&.g\&.:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-strip\-blobs\-bigger\-than 10M
.fi
.if n \{\
.RE
.\}
.sp
.sp
If you want to strip out all files with specified git object ids (hashes), list the hashes in a file and run
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-strip\-blobs\-with\-ids FILE_WITH_GIT_BLOB_IDS
.fi
.if n \{\
.RE
.\}
.sp
.sp
If you want to modify file contents, you can do so based on a list of expressions in a file, one per line\&. For example, with a file named expressions\&.txt containing
.sp
.if n \{\
.RS 4
.\}
.nf
p455w0rd
foo==>bar
glob:*666*==>
regex:\ebdriver\eb==>pilot
literal:MM/DD/YYYY==>YYYY\-MM\-DD
regex:([0\-9]{2})/([0\-9]{2})/([0\-9]{4})==>\e3\-\e1\-\e2
.fi
.if n \{\
.RE
.\}
.sp
.sp
then running
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-replace\-text expressions\&.txt
.fi
.if n \{\
.RE
.\}
.sp
.sp
will go through and replace \fBp455w0rd\fR with ***REMOVED***, \fBfoo\fR with \fBbar\fR, any line containing \fB666\fR with a blank line, the word \fBdriver\fR with \fBpilot\fR (but not if it has letters before or after; e\&.g\&. \fBdrivers\fR will be unmodified), replace the exact text \fBMM/DD/YYYY\fR with \fBYYYY\-MM\-DD\fR and replace date strings of the form MM/DD/YYYY with ones of the form YYYY\-MM\-DD\&. In the expressions file, there are a few things to note:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Every line has a replacement, given by whatever is on the right of
\fB==\fR>\&. If
\fB==\fR> does not appear on the line, the default replacement is ***REMOVED***\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Lines can start with
\fBliteral:\fR,
\fBglob:\fR, or
\fBregex:\fR
to specify whether to do literal string matches, globs (see
\m[blue]\fBhttps://docs\&.python\&.org/3/library/fnmatch\&.html\fR\m[]), or regular expressions (see
\m[blue]\fBhttps://docs\&.python\&.org/3/library/re\&.html#regular\-expression\-syntax\fR\m[])\&. If none of these are specified,
\fBliteral:\fR
is assumed\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
If multiple matches are found, all are replaced\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
globs and regexes are applied to the entire file, but without any special flags turned on\&. Some folks may be interested in adding (?m) to the regex to turn on MULTILINE mode, so that
\fB^\fR
and
\fB$\fR
match the beginning and ends of lines rather than the beginning and end of file\&. See
\m[blue]\fBhttps://docs\&.python\&.org/3/library/re\&.html\fR\m[]
for details\&.
.RE
.sp
See also the \fB\-\-blob\-callback\fR from the section called \(lqCALLBACKS\(rq\&.
.SS "Updating commit/tag messages"
.sp
If you want to modify commit or tag messages, you can do so with the same syntax as \fB\-\-replace\-text\fR, explained above\&. For example, with a file named expressions\&.txt containing
.sp
.if n \{\
.RS 4
.\}
.nf
foo==>bar
.fi
.if n \{\
.RE
.\}
.sp
.sp
then running
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-replace\-message expressions\&.txt
.fi
.if n \{\
.RE
.\}
.sp
.sp
will replace \fBfoo\fR in commit or tag messages with \fBbar\fR\&.
.sp
See also the \fB\-\-message\-callback\fR from the section called \(lqCALLBACKS\(rq\&.
.SS "Refname based filtering"
.sp
To rename tags, use \fB\-\-tag\-rename\fR, e\&.g\&.:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-tag\-rename foo:bar
.fi
.if n \{\
.RE
.\}
.sp
.sp
This will rename any tags starting with \fBfoo\fR to now start with \fBbar\fR\&. Either side of the colon could be blank, e\&.g\&.
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-tag\-rename \*(Aq\*(Aq:\*(Aqmy\-module\-\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
For more general refname modification, see \fB\-\-refname\-callback\fR from the section called \(lqCALLBACKS\(rq\&.
.SS "User and email based filtering"
.sp
To modify username and emails of commits, you can create a mailmap file in the format accepted by \fBgit-shortlog\fR(1)\&. For example, if you have a file named my\-mailmap you can run
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-mailmap my\-mailmap
.fi
.if n \{\
.RE
.\}
.sp
.sp
and if the current contents of that file are as follows (if the specified mailmap file is version controlled, historical versions of the file are ignored):
.sp
.if n \{\
.RS 4
.\}
.nf
Name For User <email@addre\&.ss>
<new@ema\&.il> <old1@ema\&.il>
New Name And <new@ema\&.il> <old2@ema\&.il>
New Name And <new@ema\&.il> Old Name And <old3@ema\&.il>
.fi
.if n \{\
.RE
.\}
.sp
.sp
then we can update username and/or emails based on the specified mapping\&.
.sp
See also the \fB\-\-name\-callback\fR and \fB\-\-email\-callback\fR from the section called \(lqCALLBACKS\(rq\&.
.SS "Parent rewriting"
.sp
To replace $commit_A with $commit_B (e\&.g\&. make all commits which had $commit_A as a parent instead have $commit_B for that parent), and rewrite history to make it permanent:
.sp
.if n \{\
.RS 4
.\}
.nf
git replace $commit_A $commit_B
git filter\-repo \-\-proceed
.fi
.if n \{\
.RE
.\}
.sp
.sp
To create a new commit with the same contents as $commit_A except with different parent(s) and then replace $commit_A with the new commit, and rewrite history to make it permanent:
.sp
.if n \{\
.RS 4
.\}
.nf
git replace \-\-graft $commit_A $new_parent_or_parents
git filter\-repo \-\-proceed
.fi
.if n \{\
.RE
.\}
.sp
.sp
The \fB\-\-proceed\fR option is needed to avoid failing the "no arguments specified" check\&. Note that older versions of git\-filter\-repo required \fB\-\-force\fR to be passed after creating a graft to avoid triggering the not\-a\-fresh\-clone check; that check has been modified to remove this overuse of \fB\-\-force\fR\&.
.SS "Partial history rewrites"
.sp
To rewrite the history on just one branch (which may cause it to no longer share any common history with other branches), use \fB\-\-refs\fR\&. For example, to remove a file named \fIextraneous\&.txt\fR from the \fImaster\fR branch:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-invert\-paths \-\-path extraneous\&.txt \-\-refs master
.fi
.if n \{\
.RE
.\}
.sp
.sp
To rewrite just some recent commits:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-invert\-paths \-\-path extraneous\&.txt \-\-refs master~3\&.\&.master
.fi
.if n \{\
.RE
.\}
.sp
.SH "CALLBACKS"
.sp
For flexibility, filter\-repo allows you to specify functions on the command line to further filter all changes\&. Please note that there are some API compatibility caveats associated with these callbacks that you should be aware of before using them; see the "API BACKWARD COMPATIBILITY CAVEAT" comment near the top of git\-filter\-repo source code\&.
.sp
Most callback functions are of the same general format (\-\-file\-info\-callback is an exception which will be noted later)\&. For a command line argument like
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-foo\-callback \*(AqBODY\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
the following code will be compiled and called:
.sp
.if n \{\
.RS 4
.\}
.nf
def foo_callback(foo):
  BODY
.fi
.if n \{\
.RE
.\}
.sp
.sp
Thus, you just need to make sure your \fIBODY\fR modifies and returns \fIfoo\fR appropriately\&. One important thing to note for all callbacks is that filter\-repo uses bytestrings (see \m[blue]\fBhttps://docs\&.python\&.org/3/library/stdtypes\&.html#bytes\fR\m[]) everywhere instead of strings\&.
.sp
There are four callbacks that allow you to operate directly on raw objects that contain data that\(cqs easy to write in \fBgit-fast-import\fR(1) format:
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-blob\-callback
\-\-commit\-callback
\-\-tag\-callback
\-\-reset\-callback
.fi
.if n \{\
.RE
.\}
.sp
.sp
We\(cqll come back to these later because it is often the case that the other callbacks are more convenient\&. The other callbacks operate on a small piece of the raw objects or operate on pieces across multiple types of raw object (e\&.g\&. author names and committer names and tagger names across commits and tags, or refnames across commits, tags, and resets, or messages across commits and tags)\&. The convenience callbacks are:
.sp
.if n \{\
.RS 4
.\}
.nf
\-\-filename\-callback
\-\-message\-callback
\-\-name\-callback
\-\-email\-callback
\-\-refname\-callback
\-\-file\-info\-callback
.fi
.if n \{\
.RE
.\}
.sp
.sp
in each you are expected to simply return a new value based on the one passed in\&. For example,
.sp
.if n \{\
.RS 4
.\}
.nf
git\-filter\-repo \-\-name\-callback \*(Aqreturn name\&.replace(b"Wiliam", b"William")\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
would result in the following function being called:
.sp
.if n \{\
.RS 4
.\}
.nf
def name_callback(name):
  return name\&.replace(b"Wiliam", b"William")
.fi
.if n \{\
.RE
.\}
.sp
.sp
The email callback is quite similar:
.sp
.if n \{\
.RS 4
.\}
.nf
git\-filter\-repo \-\-email\-callback \*(Aqreturn email\&.replace(b"\&.cm", b"\&.com")\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
The refname callback is also similar, but note that the refname passed in and returned are expected to be fully qualified (e\&.g\&. b"refs/heads/master" instead of just b"master" and b"refs/tags/v1\&.0\&.7" instead of b"1\&.0\&.7"):
.sp
.if n \{\
.RS 4
.\}
.nf
git\-filter\-repo \-\-refname\-callback \*(Aq
  # Change e\&.g\&. refs/heads/master to refs/heads/prefix\-master
  rdir,rpath = os\&.path\&.split(refname)
  return rdir + b"/prefix\-" + rpath\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
The message callback is quite similar to the previous three callbacks, though it operates on a bytestring that is likely more than one line:
.sp
.if n \{\
.RS 4
.\}
.nf
git\-filter\-repo \-\-message\-callback \*(Aq
  if b"Signed\-off\-by:" not in message:
    message += b"\enSigned\-off\-by: Me My <self@and\&.eye>"
  return re\&.sub(b"[Ee]\-?[Mm][Aa][Ii][Ll]", b"email", message)\*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
The filename callback is slightly more interesting\&. Returning None means the file should be removed from all commits, returning the filename unmodified marks the file to be kept, and returning a different name means the file should be renamed\&. An example:
.sp
.if n \{\
.RS 4
.\}
.nf
git\-filter\-repo \-\-filename\-callback \*(Aq
  if b"/src/" in filename:
    # Remove all files with a directory named "src" in their path
    # (except when "src" appears at the toplevel)\&.
    return None
  elif filename\&.startswith(b"tools/"):
    # Rename tools/ \-> scripts/misc/
    return b"scripts/misc/" + filename[6:]
  else:
    # Keep the filename and do not rename it
    return filename
  \*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.sp
The file\-info callback is more involved\&. It is designed to be used in cases where filtering depends on both filename and contents (and maybe mode)\&. It is called for file changes other than deletions (since deletions have no file contents to operate on)\&. The file info callback takes four parameters (filename, mode, blob_id, and value), and expects three to be returned (filename, mode, blob_id)\&. The filename is handled similar to the filename callback; it can be used to rename the file (or set to None to drop the change)\&. The mode is a simple bytestring (b"100644" for regular non\-executable files, b"100755" for executable files/scripts, b"120000" for symlinks, and b"160000" for submodules)\&. The blob_id is most useful in conjunction with the value parameter\&. The value parameter is an instance of a class that has the following functions value\&.get_contents_by_identifier(blob_id) \(-> contents (bytestring) value\&.get_size_by_identifier(blob_id) \(-> size_of_blob (int) value\&.insert_file_with_contents(contents) \(-> blob_id value\&.is_binary(contents) \(-> bool value\&.apply_replace_text(contents) \(-> new_contents (bytestring) and has the following member data you can write to value\&.data (dict) These functions allow you to get the contents of the file, or its size, create a new file in the stream whose blob_id you can return, check whether some given contents are binary (using the heuristic from the grep(1) command), and apply the replacement rules from \-\-replace\-text (note that \-\-file\-info\-callback makes the changes from \-\-replace\-text not auto\-apply)\&. You could use this for example to only apply the changes from \-\-replace\-text to certain file types and simultaneously rename the files it applies the changes to:
.sp
.if n \{\
.RS 4
.\}
.nf
git\-filter\-repo \-\-file\-info\-callback \*(Aq
  if not filename\&.endswith(b"\&.config"):
    # Make no changes to the file; return as\-is
    return (filename, mode, blob_id)

  new_filename = filename[0:\-7] + b"\&.cfg"

  contents = value\&.get_contents_by_identifier(blob_id)
  new_contents = value\&.apply_replace_text(contents)
  new_blob_id = value\&.insert_file_with_contents(new_contents)

  return (new_filename, mode, new_blob_id)
.fi
.if n \{\
.RE
.\}
.sp
.sp
Note that if history has multiple revisions with the same file (e\&.g\&. it was cherry\-picked to multiple branches or there were a number of reverts), then the \-\-file\-info\-callback will be called multiple times\&. If you want to avoid processing the same file multiple times, then you can stash transformation results in the value\&.data dict\&. For, example, we could modify the above example to make it only apply transformations on blob_ids we have not seen before:
.sp
.if n \{\
.RS 4
.\}
.nf
git\-filter\-repo \-\-file\-info\-callback \*(Aq
  if not filename\&.endswith(b"\&.config"):
    # Make no changes to the file; return as\-is
    return (filename, mode, blob_id)

  new_filename = filename[0:\-7] + b"\&.cfg"

  if blob_id in value\&.data:
    return (new_filename, mode, value\&.data[blob_id])

  contents = value\&.get_contents_by_identifier(blob_id)
  new_contents = value\&.apply_replace_text(contents)
  new_blob_id = value\&.insert_file_with_contents(new_contents)
  value\&.data[blob_id] = new_blob_id

  return (new_filename, mode, new_blob_id)
.fi
.if n \{\
.RE
.\}
.sp
.sp
An alternative example for the \-\-file\-info\-callback is to make all \&.sh files executable and add an extra trailing newline to the \&.sh files:
.sp
.if n \{\
.RS 4
.\}
.nf
git\-filter\-repo \-\-file\-info\-callback \*(Aq
  if not filename\&.endswith(b"\&.sh"):
    # Make no changes to the file; return as\-is
    return (filename, mode, blob_id)

  # There are only 4 valid modes in git:
  #   \- 100644, for regular non\-executable files
  #   \- 100755, for executable files/scripts
  #   \- 120000, for symlinks
  #   \- 160000, for submodules
  new_mode = b"100755"

  contents = value\&.get_contents_by_identifier(blob_id)
  new_contents = contents + b"\en"
  new_blob_id = value\&.insert_file_with_contents(new_contents)

  return (filename, new_mode, new_blob_id)
.fi
.if n \{\
.RE
.\}
.sp
.sp
In contrast to the previous callback types, the blob, reset, tag, and commit callbacks are not expected to return a value, but are instead expected to modify the object passed in\&. Major fields for these objects are (subject to API backward compatibility caveats mentioned previously):
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Blob:
\fBoriginal_id\fR
(original hash) and
\fBdata\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Reset:
\fBref\fR
(name of reference) and
\fBfrom_ref\fR
(hash or integer mark)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Tag:
\fBref\fR,
\fBfrom_ref\fR,
\fBoriginal_id\fR,
\fBtagger_name\fR,
\fBtagger_email\fR,
\fBtagger_date\fR,
\fBmessage\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Commit:
\fBbranch\fR,
\fBoriginal_id\fR,
\fBauthor_name\fR,
\fBauthor_email\fR,
\fBauthor_date\fR,
\fBcommitter_name\fR,
\fBcommitter_email\fR,
\fBcommitter_date\fR,
\fBmessage\fR,
\fBfile_changes\fR
(list of FileChange objects, each containing a
\fBtype\fR,
\fBfilename\fR,
\fBmode\fR, and
\fBblob_id\fR),
\fBparents\fR
(list of hashes or integer marks)
.RE
.sp
An example of each:
.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-blob\-callback \*(Aq
  if len(blob\&.data) > 25:
    # Mark this blob for removal from all commits
    blob\&.skip()
  else:
    blob\&.data = blob\&.data\&.replace(b"Hello", b"Goodbye")
  \*(Aq
.fi
.if n \{\
.RE
.\}
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-reset\-callback \*(Aqreset\&.ref = reset\&.ref\&.replace(b"master", b"dev")\*(Aq
.fi
.if n \{\
.RE
.\}
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-tag\-callback \*(Aq
  if tag\&.tagger_name == b"Jim Williams":
    # Omit this tag
    tag\&.skip()
  else:
    tag\&.message = tag\&.message + b"\en\enTag of %s by %s on %s" % (tag\&.ref, tag\&.tagger_email, tag\&.tagger_date)\*(Aq
.fi
.if n \{\
.RE
.\}
.sp

.sp
.if n \{\
.RS 4
.\}
.nf
git filter\-repo \-\-commit\-callback \*(Aq
  # Remove executable files with three 6s in their name (including
  # from leading directories)\&.
  # Also, undo deletion of sources/foo/bar\&.txt (change types are
  # either b"D" (deletion) or b"M" (add or modify); renames are
  # handled by deleting the old file and adding a new one)
  commit\&.file_changes = [
         change for change in commit\&.file_changes
         if not (change\&.mode == b"100755" and
                 change\&.filename\&.count(b"6") == 3) and
            not (change\&.type == b"D" and
                 change\&.filename == b"sources/foo/bar\&.txt")]
  # Mark all \&.sh files as executable; modes in git are always one of
  # 100644 (normal file), 100755 (executable), 120000 (symlink), or
  # 160000 (submodule)
  for change in commit\&.file_changes:
    if change\&.filename\&.endswith(b"\&.sh"):
      change\&.mode = b"100755"
  \*(Aq
.fi
.if n \{\
.RE
.\}
.sp
.SH "INTERNALS"
.sp
You probably don\(cqt need to read this section unless you are just very curious or you are trying to do a very complex history rewrite\&.
.SS "How filter\-repo works"
.sp
Roughly, filter\-repo works by running
.sp
.if n \{\
.RS 4
.\}
.nf
git fast\-export <options> | filter | git fast\-import <options>
.fi
.if n \{\
.RE
.\}
.sp
.sp
where filter\-repo not only launches the whole pipeline but also serves as the \fIfilter\fR in the middle\&. However, filter\-repo does a few additional things on top in order to make it into a well\-rounded filtering tool\&. A sequence that more accurately reflects what filter\-repo runs is:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Verify we\(cqre in a fresh clone
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
\fBgit\fR
\fBfetch\fR
\fB\-u\fR
\&.
\fBrefs/remotes/origin/\fR*:refs/heads/*
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
\fBgit\fR
\fBremote\fR
\fBrm\fR
\fBorigin\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
\fBgit\fR
\fBfast\-export\fR
\fB\-\-show\-original\-ids\fR
\fB\-\-reference\-excluded\-parents\fR
\fB\-\-fake\-missing\-tagger\fR
\fB\-\-signed\-tags=strip\fR
\fB\-\-tag\-of\-filtered\-object=rewrite\fR
\fB\-\-use\-done\-feature\fR
\fB\-\-no\-data\fR
\fB\-\-reencode=yes\fR
\fB\-\-mark\-tags\fR
\fB\-\-all\fR
|
\fBfilter\fR
|
\fBgit\fR
\fB\-c\fR
\fBcore\&.ignorecase=false\fR
\fBfast\-import\fR
\fB\-\-date\-format=raw\-permissive\fR
\fB\-\-force\fR
\fB\-\-quiet\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
\fBgit\fR
\fBupdate\-ref\fR
\fB\-\-no\-deref\fR
\fB\-\-stdin\fR, fed with a list of refs to nuke, and a list of replace refs to delete, create, or update\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
\fBgit\fR
\fBreset\fR
\fB\-\-hard\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
\fBgit\fR
\fBreflog\fR
\fBexpire\fR
\fB\-\-expire=now\fR
\fB\-\-all\fR
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
\fBgit\fR
\fBgc\fR
\fB\-\-prune=now\fR
.RE
.sp
Some notes or exceptions on each of the above:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
If we\(cqre not in a fresh clone, users will not be able to recover if they used the wrong command or ran in the wrong repo\&. (Though
\fB\-\-force\fR
overrides this check, and it\(cqs also off if you\(cqve already ran filter\-repo once in this repo\&.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
Technically, we actually use a
\fBgit\fR
\fBupdate\-ref\fR
command fed with a lot of input due to the fact that users can use
\fB\-\-force\fR
when local branches might not match remote branches\&. But this fetch command catches the intent rather succinctly\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
We don\(cqt want users accidentally pushing back to the original repo, as discussed in
the section called \(lqDISCUSSION\(rq\&. It also reminds users that since history has been rewritten, this repo is no longer compatible with the original\&. Finally, another minor benefit is this allows users to push with the
\fB\-\-mirror\fR
option to their new home without accidentally sending remote tracking branches\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
Some of these flags are always used but others are actually conditional\&. For example, filter\-repo\(cqs
\fB\-\-replace\-text\fR
and
\fB\-\-blob\-callback\fR
options need to work on blobs so
\fB\-\-no\-data\fR
cannot be passed to fast\-export\&. But when we don\(cqt need to work on blobs, passing
\fB\-\-no\-data\fR
speeds things up\&. Also, other flags may change the structure of the pipeline as well (e\&.g\&.
\fB\-\-dry\-run\fR
and
\fB\-\-debug\fR)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
We use this step to write replace refs for accessing the newly written commit hashes using their previous names\&. Also, if refs were renamed by various steps, we need to delete the old refnames in order to avoid mixing old and new history\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
Users also have old versions of files in their working tree and index; we want those cleaned up to match the rewritten history as well\&. Note that this step is skipped in bare repos\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
Reflogs will hold on to old history, so we need to expire them\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 8.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  8." 4.2
.\}
We need to gc to avoid mixing new and old history\&. Also, it shrinks the repository for users, so they don\(cqt have to do extra work\&. (Odds are that they\(cqve only rewritten trees and commits and maybe a few blobs, so
\fB\-\-aggressive\fR
isn\(cqt needed and would be too slow\&.)
.RE
.sp
Information about these steps is printed out when \fB\-\-debug\fR is passed to filter\-repo\&. When doing a \fB\-\-partial\fR history rewrite, steps 2, 3, 7, and 8 are unconditionally skipped, step 5 is skipped if \fB\-\-replace\-refs\fR is \fBupdate\-no\-add\fR, and just the nuke\-unused\-refs portion of step 5 is skipped if \fB\-\-replace\-refs\fR is something else\&.
.SS "Limitations"
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBInherited limitations\fR
.RS 4
.sp
Since git filter\-repo calls fast\-export and fast\-import to do a lot of the heavy lifting, it inherits limitations from those systems:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
extended commit headers, if any, are stripped
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
commits get rewritten meaning they will have new hashes; therefore, signatures on commits and tags cannot continue to work and instead are just removed (thus signed tags become annotated tags)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
tags of commits are supported\&. Prior to git\-2\&.24\&.0, tags of blobs and tags of tags are not supported (fast\-export would die on such tags)\&. tags of trees are not supported in any git version (since fast\-export ignores tags of trees with a warning and fast\-import provides no way to import them)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
annotated and signed tags outside of the refs/tags/ namespace are not supported (their location will be mangled in weird ways)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
fast\-import will die on various forms of invalid input, such as a timezone with more than four digits
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
fast\-export cannot reencode commit messages into UTF\-8 if the commit message is not valid in its specified encoding (in such cases, it\(cqll leave the commit message and the encoding header alone)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
commits without an author will be given one matching the committer
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
tags without a tagger will be given a fake tagger
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
references that include commit cycles in their history (which can be created with
\fBgit-replace\fR(1)) will not be flagged to the user as an error but will be silently deleted by fast\-export as though the branch or tag contained no interesting files
.RE
.sp
There are also some limitations due to the design of these systems:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Trying to insert additional files into the stream can be tricky; since fast\-export only lists file changes in a merge relative to its first parent, if you insert additional files into a commit that is in the second (or third or fourth) parent history of a merge, then you also need to add it to the merge manually\&. (Similarly, if you change which parent is the first parent in a merge commit, you need to manually update the list of file changes to be relative to the new first parent\&.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
fast\-export and fast\-import work with exact file contents, not patches\&. (e\&.g\&. "Whatever the current contents of this file, update them to now have these contents") Because of this, removing the changes made in a single commit or inserting additional changes to a file in some commit and expecting them to propagate forward is not something that can be done with these tools\&. Use
\fBgit-rebase\fR(1)
for that\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBIntrinsic limitations\fR
.RS 4
.sp
Some types of filtering have limitations that would affect any tool attempting to perform them; the most any tool can do is attempt to notify the user when it detects an issue:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
When rewriting commit hashes in commit messages, there are a variety of cases when the hash will not be updated (whenever this happens, a note is written to
\fB\&.git/filter\-repo/suboptimal\-issues\fR):
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
if a commit hash does not correspond to a commit in the old repo
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
if a commit hash corresponds to a commit that gets pruned
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
if an abbreviated hash is not unique
.RE
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Pruning of empty commits can cause a merge commit to lose an entire ancestry line and become a non\-merge\&. If the merge commit had no changes then it can be pruned too, but if it still has changes it needs to be kept\&. This might cause minor confusion since the commit will likely have a commit message that makes it sound like a merge commit even though it\(cqs not\&. (Whenever a merge commit becomes a non\-merge commit, a note is written to
\fB\&.git/filter\-repo/suboptimal\-issues\fR)
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBIssues specific to filter-repo\fR
.RS 4
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Multiple repositories in the wild have been observed which use a bogus timezone (\fB+051800\fR); google will find you some reports\&. The intended timezone wasn\(cqt clear or wasn\(cqt always the same\&. Replace with a different bogus timezone that fast\-import will accept (\fB+0261\fR)\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
\fB\-\-path\-rename\fR
can result in pathname collisions; to avoid excessive memory requirements of tracking which files are in all commits or looking up what files exist with either every commit or every usage of \-\-path\-rename, we just tell the user that they might clobber other changes if they aren\(cqt careful\&. We can check if the clobbering comes from another \-\-path\-rename without much overhead\&. (Perhaps in the future it\(cqs worth adding a slow mode to \-\-path\-rename that will do the more exhaustive checks?)
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
There is no mechanism for directly controlling which flags are passed to fast\-export (or fast\-import); only pre\-defined flags can be turned on or off as a side\-effect of other options\&. Direct control would make little sense because some options like
\fB\-\-full\-tree\fR
would require additional code in filter\-repo (to parse new directives), and others such as
\fB\-M\fR
or
\fB\-C\fR
would break assumptions used in other places of filter\-repo\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Partial\-repo filtering, while supported, runs counter to filter\-repo\(cqs "avoid mixing old and new history" design\&. This support has required improvements to core git as well (e\&.g\&. it depends upon the
\fB\-\-reference\-excluded\-parents\fR
option to fast\-export that was added specifically for this usage within filter\-repo)\&. The
\fB\-\-partial\fR
and
\fB\-\-refs\fR
options will continue to be supported since there are people with usecases for them; however, I am concerned that this inconsistency about mixing old and new history seems likely to lead to user mistakes\&. For now, I just hope that long explanations of caveats in the documentation of these options suffice to curtail any such problems\&.
.RE
.RE
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBComments on reversibility\fR
.RS 4
.sp
Some people are interested in reversibility of a rewrite; e\&.g\&. rewrite history, possibly add some commits, then unrewrite and get the original history back plus a few new "unrewritten" commits\&. Obviously this is impossible if your rewrite involves throwing away information (e\&.g\&. filtering out files or replacing several different strings with ***REMOVED***), but may be possible with some rewrites\&. filter\-repo is likely to be a poor fit for this type of workflow for a few reasons:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
most of the limitations inherited from fast\-export and fast\-import are of a type that cause reversibility issues
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
grafts and replace refs, if present, are used in the rewrite and made permanent
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
rewriting of commit hashes will probably be reversible, but it is possible for rewritten abbreviated hashes to not be unique even if the original abbreviated hashes were\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
filter\-repo defaults to several forms of irreversible rewriting that you may need to turn off (e\&.g\&. the last two bullet points above or reencoding commit messages into UTF\-8); it\(cqs possible that additional forms of irreversible rewrites will be added in the future\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
I assume that people use filter\-repo for one\-shot conversions, not ongoing data transfers\&. I explicitly reserve the right to change any API in filter\-repo based on this presumption (and a comment to this effect is found in multiple places in the code and examples)\&. You have been warned\&.
.RE
.RE
.SH "SEE ALSO"
.sp
\fBgit-rebase\fR(1), \fBgit-filter-branch\fR(1)
.SH "GIT"
.sp
Part of the \fBgit\fR(1) suite
.SH "NOTES"
.IP " 1." 4
GitLab\(cqs docs on reducing repository size
.RS 4
\%https://docs.gitlab.com/ee/user/project/repository/reducing_the_repo_size_using_git.html
.RE
.IP " 2." 4
the "Fully removing the data from GitHub" section of GitHub\(cqs docs
.RS 4
\%https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository#fully-removing-the-data-from-github
.RE
